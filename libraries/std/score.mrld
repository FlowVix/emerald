

let COMP_TYPES = {
    EQ: 0,
    GREATER: 1,
    GREATER_EQ: 2,
    LESSER: 3,
    LESSER_EQ: 4,
}


export struct Score {
    id: number,
}

export struct ScoreComp {
    comp: number,
    left: Score,
    right: number | Score,
}





let id_counter = 0;
impl Score {

    new: (default: number) => {
        command("scoreboard players set mrld_" + string(id_counter) + " mrld_store " + string(floor(default)));
        return Score::{
            id: (id_counter += 1) - 1,
        }
    },
    str: (self) => "mrld_" + string(self.id) + " mrld_store",
    clone: (self) => {
        let c = Score::new(0);
        c.set(self);
        return c;
    },
    print: (self) => {
        command(
            "tellraw @a {\"score\":{\"name\":\"" +
            "mrld_" + string(self.id) +
            "\",\"objective\":\"mrld_store\"}}"
        );
    },

    add: (self, other: number | Score) => {
        if other is number {
            let other = floor(other);
            if other < 0 {
                self.subtract(-other);
            } else {
                command("scoreboard players add " + self.str() + " " + string(other));
            }
        } else {
            command("scoreboard players operation " + self.str() + " += " + other.str());
        }
    },
    subtract: (self, other: number | Score) => {
        if other is number {
            let other = floor(other);
            if other < 0 {
                self.add(-other);
            } else {
                command("scoreboard players remove " + self.str() + " " + string(other));
            }
        } else {
            command("scoreboard players operation " + self.str() + " -= " + other.str());
        }
    },
    multiply: (self, other: number | Score) => {
        if other is number {
            let other = floor(other);
            let str = (if (other < 0) "n_int_" + string(-other) else "int_" + string(other)) + " mrld_store";
            command("scoreboard players set " + str + " " + string(other));
            command("scoreboard players operation " + self.str() + " *= " + str);
        } else {
            command("scoreboard players operation " + self.str() + " *= " + other.str());
        }
    },
    divide: (self, other: number | Score) => {
        if other is number {
            let other = floor(other);
            let str = (if (other < 0) "n_int_" + string(-other) else "int_" + string(other)) + " mrld_store";
            command("scoreboard players set " + str + " " + string(other));
            command("scoreboard players operation " + self.str() + " /= " + str);
        } else {
            command("scoreboard players operation " + self.str() + " /= " + other.str());
        }
    },
    modulo: (self, other: number | Score) => {
        if other is number {
            let other = floor(other);
            let str = (if (other < 0) "n_int_" + string(-other) else "int_" + string(other)) + " mrld_store";
            command("scoreboard players set " + str + " " + string(other));
            command("scoreboard players operation " + self.str() + " %= " + str);
        } else {
            command("scoreboard players operation " + self.str() + " %= " + other.str());
        }
    },
    set: (self, other: number | Score) => {
        if other is number {
            let other = floor(other);
            command("scoreboard players set " + self.str() + " " + string(other));
        } else {
            command("scoreboard players operation " + self.str() + " = " + other.str());
        }
    },

    
    _plus_eq_: (self, v: number | Score) => {
        self.add(v);
    },
    _minus_eq_: (self, v: number | Score) => {
        self.subtract(v);
    },
    _mult_eq_: (self, v: number | Score) => {
        self.multiply(v);
    },
    _div_eq_: (self, v: number | Score) => {
        self.divide(v);
    },
    _mod_eq_: (self, v: number | Score) => {
        self.modulo(v);
    },
    _assign_: (self, v: number | Score) => {
        self.set(v);
    },

    _plus_: (self, v: number | Score) => {
        let c = self.clone();
        c.add(v);
        return c;
    },
    _minus_: (self, v: number | Score) => {
        let c = self.clone();
        c.subtract(v);
        return c;
    },
    _mult_: (self, v: number | Score) => {
        let c = self.clone();
        c.multiply(v);
        return c;
    },
    _div_: (self, v: number | Score) => {
        let c = self.clone();
        c.divide(v);
        return c;
    },
    _mod_: (self, v: number | Score) => {
        let c = self.clone();
        c.modulo(v);
        return c;
    },

    _eq_: (self, v: number | Score) => {
        return ScoreComp::{
            comp: COMP_TYPES.EQ,
            left: self,
            right: v,
        }
    },
    _greater_: (self, v: number | Score) => {
        return ScoreComp::{
            comp: COMP_TYPES.GREATER,
            left: self,
            right: v,
        }
    },
    _greater_eq_: (self, v: number | Score) => {
        return ScoreComp::{
            comp: COMP_TYPES.GREATER_EQ,
            left: self,
            right: v,
        }
    },
    _lesser_: (self, v: number | Score) => {
        return ScoreComp::{
            comp: COMP_TYPES.LESSER,
            left: self,
            right: v,
        }
    },
    _lesser_eq_: (self, v: number | Score) => {
        return ScoreComp::{
            comp: COMP_TYPES.LESSER_EQ,
            left: self,
            right: v,
        }
    },
}


impl ScoreComp {
    then: (self, f: mc_func) => {
        let cond = "";
        if self.right is number {
            let value = floor(self.right);
            cond =
                if (self.comp == COMP_TYPES.EQ) "matches " + string(value)
                else if (self.comp == COMP_TYPES.GREATER) "matches " + string(value+1) + ".."
                else if (self.comp == COMP_TYPES.GREATER_EQ) "matches " + string(value) + ".."
                else if (self.comp == COMP_TYPES.LESSER) "matches .." + string(value-1)
                else if (self.comp == COMP_TYPES.LESSER_EQ) "matches .." + string(value);
        } else {
            cond =
                if (self.comp == COMP_TYPES.EQ) "= " + self.right.str()
                else if (self.comp == COMP_TYPES.GREATER) "> " + self.right.str()
                else if (self.comp == COMP_TYPES.GREATER_EQ) ">= " + self.right.str()
                else if (self.comp == COMP_TYPES.LESSER) "< " + self.right.str()
                else if (self.comp == COMP_TYPES.LESSER_EQ) "<= " + self.right.str();
        }
        command("execute if score " + self.left.str() + " " + cond + " run " + func_str(f));
    },
}



