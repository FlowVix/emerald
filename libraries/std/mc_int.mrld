


let {
    McInt,
    ScoreRange,
    CompType,
    RuntimeCondition,
} = import? "types.mrld";

export let McInt = McInt;

let id_counter = 0;

impl McInt {

    new: (default: number) => {
        command("scoreboard players set mrld_" + string(id_counter) + " mrld_store " + string(floor(default)));
        return McInt::{
            id: (id_counter += 1) - 1,
        }
    },
    str: (self) => "mrld_" + string(self.id) + " mrld_store",
    clone: (self) => {
        let c = McInt::new(0);
        c.set(self);
        return c;
    },
    print: (self) => {
        command(
            "tellraw @a {\"score\":{\"name\":\"" +
            "mrld_" + string(self.id) +
            "\",\"objective\":\"mrld_store\"}}"
        );
    },

    add: (self, other: number | McInt) => {
        if other is number {
            let other = floor(other);
            if other < 0 {
                self.subtract(-other);
            } else {
                command("scoreboard players add " + self.str() + " " + string(other));
            }
        } else {
            command("scoreboard players operation " + self.str() + " += " + other.str());
        }
    },
    subtract: (self, other: number | McInt) => {
        if other is number {
            let other = floor(other);
            if other < 0 {
                self.add(-other);
            } else {
                command("scoreboard players remove " + self.str() + " " + string(other));
            }
        } else {
            command("scoreboard players operation " + self.str() + " -= " + other.str());
        }
    },
    multiply: (self, other: number | McInt) => {
        if other is number {
            let other = floor(other);
            let str = (if (other < 0) "n_int_" + string(-other) else "int_" + string(other)) + " mrld_store";
            command("scoreboard players set " + str + " " + string(other));
            command("scoreboard players operation " + self.str() + " *= " + str);
        } else {
            command("scoreboard players operation " + self.str() + " *= " + other.str());
        }
    },
    divide: (self, other: number | McInt) => {
        if other is number {
            let other = floor(other);
            let str = (if (other < 0) "n_int_" + string(-other) else "int_" + string(other)) + " mrld_store";
            command("scoreboard players set " + str + " " + string(other));
            command("scoreboard players operation " + self.str() + " /= " + str);
        } else {
            command("scoreboard players operation " + self.str() + " /= " + other.str());
        }
    },
    modulo: (self, other: number | McInt) => {
        if other is number {
            let other = floor(other);
            let str = (if (other < 0) "n_int_" + string(-other) else "int_" + string(other)) + " mrld_store";
            command("scoreboard players set " + str + " " + string(other));
            command("scoreboard players operation " + self.str() + " %= " + str);
        } else {
            command("scoreboard players operation " + self.str() + " %= " + other.str());
        }
    },
    set: (self, other: number | McInt) => {
        if other is number {
            let other = floor(other);
            command("scoreboard players set " + self.str() + " " + string(other));
        } else {
            command("scoreboard players operation " + self.str() + " = " + other.str());
        }
    },

    to_const: (self, r: range, f: function) => {
        let score = self.clone();
        for i in r {
            (score == i).then(!{f(i);});
        }
    },
    abs: (self) => {
        let r = self.clone();
        (self < 0).then(!{
            r *= -1;
        });
        return r;
    },

    
    _plus_eq_: (self, v: number | McInt) => {
        self.add(v);
    },
    _minus_eq_: (self, v: number | McInt) => {
        self.subtract(v);
    },
    _mult_eq_: (self, v: number | McInt) => {
        self.multiply(v);
    },
    _div_eq_: (self, v: number | McInt) => {
        self.divide(v);
    },
    _mod_eq_: (self, v: number | McInt) => {
        self.modulo(v);
    },
    _assign_: (self, v: number | McInt) => {
        self.set(v);
    },

    _plus_: (self, v: number | McInt) => {
        let c = self.clone();
        c.add(v);
        return c;
    },
    _minus_: (self, v: number | McInt) => {
        let c = self.clone();
        c.subtract(v);
        return c;
    },
    _mult_: (self, v: number | McInt) => {
        let c = self.clone();
        c.multiply(v);
        return c;
    },
    _div_: (self, v: number | McInt) => {
        let c = self.clone();
        c.divide(v);
        return c;
    },
    _mod_: (self, v: number | McInt) => {
        let c = self.clone();
        c.modulo(v);
        return c;
    },

    _eq_: (self, v: number | McInt) => {
        return RuntimeCondition:Comparison {
            left: self,
            comp: CompType:Equal,
            right: v,
        }
    },
    _greater_: (self, v: number | McInt) => {
        return RuntimeCondition:Comparison {
            left: self,
            comp: CompType:Greater,
            right: v,
        }
    },
    _greater_eq_: (self, v: number | McInt) => {
        return RuntimeCondition:Comparison {
            left: self,
            comp: CompType:GreaterEq,
            right: v,
        }
    },
    _lesser_: (self, v: number | McInt) => {
        return RuntimeCondition:Comparison {
            left: self,
            comp: CompType:Lesser,
            right: v,
        }
    },
    _lesser_eq_: (self, v: number | McInt) => {
        return RuntimeCondition:Comparison {
            left: self,
            comp: CompType:LesserEq,
            right: v,
        }
    },

    _range_: (self, v: number | McInt) => {
        return ScoreRange::{
            start: self,
            end: v,
            step: 1,
        }
    },
    _r_range_: (self, v: number | McInt) => {
        return ScoreRange::{
            start: v,
            end: self,
            step: 1,
        }
    },

}

impl ScoreRange {
    _range_: (self, v: number | McInt) => {
        return ScoreRange::{
            start: self.start,
            end: self.end,
            step: v,
        }
    },
}




