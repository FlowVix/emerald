

let {
    McInt,
    McFloat,
    CompType,
    RuntimeCondition,
} = import? "types.mrld";

export let RuntimeCondition = RuntimeCondition;

impl RuntimeCondition {
    then: (self, f: mc_func) => {

        match self {
            case RuntimeCondition:Comparison { left, comp, right } -> {
                match left {
                    McInt -> {
                        let cond = "";
                        match right {
                            number -> {
                                let whole = floor(right);

                                if right == whole {
                                    cond = match comp {
                                        case CompType:Equal -> "matches " + string(whole),
                                        case CompType:Greater -> "matches " + string(whole+1) + "..",
                                        case CompType:GreaterEq -> "matches " + string(whole) + "..",
                                        case CompType:Lesser -> "matches .." + string(whole-1),
                                        case CompType:LesserEq -> "matches .." + string(whole),
                                    }
                                } else {
                                    cond = match comp {
                                        case CompType:Equal -> {return;},
                                        case CompType:Greater -> "matches " + string(whole+1) + "..",
                                        case CompType:GreaterEq -> "matches " + string(whole + 1) + "..",
                                        case CompType:Lesser -> "matches .." + string(whole),
                                        case CompType:LesserEq -> "matches .." + string(whole),
                                    }
                                }

                                command("execute if score " + left.str() + " " + cond + " run " + f.str);
                            },
                            McInt -> {
                                cond = match comp {
                                    case CompType:Equal -> "= " + right.str(),
                                    case CompType:Greater -> "> " + right.str(),
                                    case CompType:GreaterEq -> ">= " + right.str(),
                                    case CompType:Lesser -> "< " + right.str(),
                                    case CompType:LesserEq -> "<= " + right.str(),
                                }
                                command("execute if score " + left.str() + " " + cond + " run " + f.str);
                            },
                            McFloat -> {
                                let diff = right - left;
                                match comp {
                                    case CompType:Equal -> diff.is_0().then(f),
                                    case CompType:Greater -> diff.is_negative().then(f),
                                    case CompType:GreaterEq -> (diff.is_negative() || diff.is_0()).then(f),
                                    case CompType:Lesser -> diff.is_over_0().then(f),
                                    case CompType:LesserEq -> diff.is_positive().then(f),
                                }
                            },
                        }
                    },
                    McFloat -> {
                        let diff = left - right;
                        
                        match comp {
                            case CompType:Equal -> diff.is_0().then(f),
                            case CompType:Greater -> diff.is_over_0().then(f),
                            case CompType:GreaterEq -> diff.is_positive().then(f),
                            case CompType:Lesser -> diff.is_negative().then(f),
                            case CompType:LesserEq -> (diff.is_negative() || diff.is_0()).then(f),
                        }
                    }
                }
            },
            case RuntimeCondition:And (left, right) -> {
                left.then(!{
                    right.then(f);
                });
            },
            case RuntimeCondition:Or (left, right) -> {
                let cond_check = McInt::new(0);
                let add = !{
                    cond_check += 1;
                }
                left.then(add);
                right.then(add);
                (cond_check > 0).then(f);
            },
            case RuntimeCondition:IsBlock { pos, id } -> {
                command("execute if block " + string(pos.x) + " " + string(pos.y) + " " + string(pos.z) + " " + id + " run " + f.str);
            },
        }
    },
    then_else: (self, f: mc_func, otherwise: mc_func) => {
        let is_true = McInt::new(0);
        self.then(!{is_true += 1;});

        (is_true == 1).then(f);
        (is_true == 0).then(otherwise);
    },

    _and_: (self, other: RuntimeCondition) => {
        return RuntimeCondition:And (self, other);
    },
    _or_: (self, other: RuntimeCondition) => {
        return RuntimeCondition:Or (self, other);
    }


}